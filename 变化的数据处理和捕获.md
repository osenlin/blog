# 变化的数据处理和捕获
在数据爆发式增长的时代，记录数据变化和演变，探究内在规律并运用到生产实践中，驱动业务的增长成为这个时代主旋律。本文就如何记录数据变化，处理数据变化谈谈自己的理解
## 变化数据的存储
### 1.1. 覆盖重写  
所要更改的属性，始终保持最新值，即覆盖重写，但是该技术破坏了历史情况。需要借助其他的方式才能进行处理，这点我们在本文下面会讲到。
### 1.2. 增加新行  
当发生属性的变化时候，不修改原来的行，而是增加新的记录行。所以原先表的设计时候，主键更加需要具备一般意义的类型，因为会出现多行共同描述一个对象，共同描述一个对象的相同成员（属性）。采用这种方式最少需要三个额外的列：行有效的时间戳，行失效的时间戳，当前行的标识。
### 1.3. 增加新属性
对原先修改的值，不变。对新变化的值，采用新增一列，来记录。这种运用场合有限，eg，freeschema类型的数据库，且变化频度有限且低的场合。
### 1.4. 增加新表
增加新的表，用来记录变化。这种一般用在源表数据量大，且属性变化较快的表，新表要维护一个属性和源表的映射。优点是对源表无侵入性修改，对写是友好的。而查询需要连表查询，会有一定的影响
### 1.5. 增加新表，同时对源表进行重写
增加新的表，用来记录变化，同时对原表的需要修改的记录进行重写，即新表纯粹就是用来记录变化的历史，优点是对源表查询是只需要查询源表，写入速度会有一定影响  

## 变化数据的捕获  
在`变化数据的存储`一节中，我们谈到了对变化数据存储。从方式2-5都可以对历史进行捕获。如果一个系统对原先变化数据有处理需求，在系统设计之初可以参考上面的方式。从源头开始设计会对后面的数据处理带来**极大便利**。如果是现有系统，且设计之初没有考虑对变化数据的处理。可以借助下面几种方式。
### 2.1 增加标记位  
在1.1的基础之上，增加一个行变化的有效标记位。让下游系统可以进行捕获。优点需要修改的地方较为简单：1.对数据库物理设计调整，2.现有应用系统的业务逻辑进行简单调整
```
update source_table 
set update_col=col_value,valid=1 
where pk_col=pk_col_value
```
需要考虑的地方：  
1. 原系统相同记录俩次更新间隙，下游系统没有及时
